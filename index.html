<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="./index.css" />
</head>

<body>
  <div id="main">
    <table id="table">

    </table>
    <button id="edit">Edit mode: OFF</button>
    <br>
    <div>
      <br>
      Terrain
      <br>
      <button id="path">path</button>
      <button id="grass">grass</button>
      <button id="mud">mud</button>
      <button id="wall">wall</button>
    </div>
    <div>
      <br>
      Board
      <br>
      <button id="clear">clear</button>
      <button id="findPath">Find a path!</button>
      <button id="setSize">Set board size</button>
    </div>
    <div id="result"></div>
    <br>
    <div>
      <u><em style="font-weight: bold; font-size: larger;">How-to ?</em></u>
      <ol type="1">
        <li>Click on any square and hit 'e' to select start position</li>
        <li>Click on any square and hit 'x' to select goal position</li>
        <li>Enable editing mode and choose from path / grass / mud / wall (costs 1, 2, 3, x) respectively</li>
        <li>Move mouse over squares to fill with selected terrain</li>
        <li>Hit find a path !</li>
      </ol>
        Output xplanation: '[x]v' shows visited tiles with path cost so far while yellow tiles are the computed shortest path
    </div>
    <br>
    <pre>Algorithm xplanation
    A* is the same as best-first search with evaluation function = path-cost (cost upto current node) + heuristic (cost to goal from current)

    Path cost = g(n) = 1 / 2 / 3 (depends on terrain tiles)
    Heuristic = h(n) = Manhattan distance between current node and goal

    Goal finding algorithm (A*)
    1. Pushes the start node (marked 'E') into the (priority) queue ordered by h(n)
    2. Gets a node from the queue
    3. Expands the node to get its neighbours
    4. Checks each neighbour
      a) Wall (cost 'x') -> skip
      b) neighbour exists in reached -> skip
      c) new cost for this particular path >= exisiting cost for this node -> skip
      else adds the neighbour to frontier for expansion with queue cost as manhattan distance to the goal
    5. repeat steps 2 to 4 until queue is empty or goal state reached.

    Path printing Algorithm
    1. Check if goal tile was reached
    2. Get tile cameFrom[goalTile] and append to path array
    3. Check if tile == start position
      a) yes -> return path array
      b) no go to step 2
    </pre>
  </div>
  <script type="module" src="index.js"></script>
</body>

</html>